import OnCacheLineEvictedEventArgs from "../../Simulation/Events/OnCacheLineEvictedEventArgs";
import OnCacheLineLoadedEventArgs from "../../Simulation/Events/OnCacheLineLoadedEventArgs";
import OnMemoryAccessedEventArgs from "../../Simulation/Events/OnMemoryAccessedEventArgs";
import IMatrixRenderer from "./MatrixRenderer";

/// Matrix renderer that modifies the DOM to display the matrix visualization.
export default class DomMatrixRenderer implements IMatrixRenderer
{
	/// Function that changes the color of a matrix element in the DOM.
	private readonly _changeMatrixElement:
		(
			x: number,
			y: number,
			value: number | null,
			color: string,
			textColor: string
		) => void;

	/// Color to use for matrix elements present in the cache.
	private readonly _loadedColor: string;

	/// Color to use for text in matrix elements present in the cache.
	private readonly _loadedTextColor: string;

	/// Color to use for matrix elements not present in the cache.
	private readonly _unloadedColor: string;

	/// Color to use for text in matrix elements not present in the cache.
	private readonly _unloadedTextColor: string;

	/// Color to use for matrix elements accessed by the simulation.
	private readonly _accessedColor: string;

	/// Color to use for text in matrix elements accessed by the simulation.
	private readonly _accessedTextColor: string;

	/// Width of the matrix.
	private readonly _matrixX: number;

	/// Height of the matrix.
	private readonly _matrixY: number;

	/// Keeps track of the most recently accessed matrix element.
	private _activeElement: readonly [number, number] | null = null;

	/// Creates a new DOM simulation renderer.
	/// @param changeMatrixElement Function that changes the color of a matrix
	///   element in the DOM. The x and y coordinates specify the matrix element
	///   to change. The value specifies the value to change the matrix element
	///   to (or null if the value should not change) The color string specifies
	///   the color to change the matrix element to, and the text color string
	///   specifies the color to change the text in the matrix element to.
	/// @param loadedColor Color to use for matrix elements present in the cache.
	/// @param loadedTextColor Color to use for text in matrix elements present
	///   in the cache.
	/// @param unloadedColor Color to use for matrix elements not present in the
	///   cache.
	/// @param unloadedTextColor Color to use for text in matrix elements not
	///   present in the cache.
	/// @param accessedColor Color to use for matrix elements accessed by the
	///   simulation.
	/// @param accessedTextColor Color to use for text in matrix elements
	///   accessed by the simulation.
	/// @param matrixX Width of the matrix.
	/// @param matrixY Height of the matrix.
	constructor(
		changeMatrixElement: (
			x: number,
			y: number,
			value: number | null,
			color: string,
			textColor: string
		) => void,
		loadedColor: string,
		loadedTextColor: string,
		unloadedColor: string,
		unloadedTextColor: string,
		accessedColor: string,
		accessedTextColor: string,
		matrixX: number,
		matrixY: number)
	{
		this._changeMatrixElement = changeMatrixElement;
		this._loadedColor = loadedColor;
		this._loadedTextColor = loadedTextColor;
		this._unloadedColor = unloadedColor;
		this._unloadedTextColor = unloadedTextColor;
		this._accessedColor = accessedColor;
		this._accessedTextColor = accessedTextColor;
		this._matrixX = matrixX;
		this._matrixY = matrixY;
	}

	/// Invoked when the simulation visualization begins.
	public onSimulationStarted(): void
	{
		// Set all matrix elements to unloaded
		for (let x = 0; x < this._matrixX; x++)
		{
			for (let y = 0; y < this._matrixY; y++)
			{
				this._changeMatrixElement(
					x,
					y,
					null,
					this._unloadedColor,
					this._unloadedTextColor
				);
			}
		}
	}

	/// Invoked when the simulation visualization completes.
	public onSimulationFinished(): void
	{
		// Clear the active element so that it doesn't remain highlighted
		this.clearActiveElement();
	}

	/// Invoked whenever a cache line is loaded into the cache.
	/// @param eventArgs Event arguments generated by the simulation.
	public onCacheLineLoaded(eventArgs: OnCacheLineLoadedEventArgs): void
	{
		// Set each element in the cache line to loaded
		for (let i = 0; i < eventArgs.size; i++)
		{
			const memoryIndex = eventArgs.memoryIndex + i;
			const matrixCoord = this.toMatrixCoordinate(memoryIndex);

			this._changeMatrixElement(
				matrixCoord[0],
				matrixCoord[1],
				null,
				this._loadedColor,
				this._loadedTextColor
			);
		}
	}

	/// Invoked whenever a cache line is evicted from the cache.
	/// @param eventArgs Event arguments generated by the simulation.
	public onCacheLineEvicted(eventArgs: OnCacheLineEvictedEventArgs): void
	{
		// If the active element is in the evicted cache line, clear it
		if (this._activeElement !== null)
		{
			// Calculate the memory index of the active element
			const memoryIndex = this.toMemoryIndex(
				this._activeElement[0],
				this._activeElement[1]
			);

			// If the memory index is in the evicted cache line, clear the
			//   active element
			if (memoryIndex >= eventArgs.memoryIndex &&
				memoryIndex < eventArgs.memoryIndex + eventArgs.size)
			{
				this.clearActiveElement();
			}
		}

		// Set each element in the cache line to unloaded
		for (let i = 0; i < eventArgs.size; i++)
		{
			const memoryIndex = eventArgs.memoryIndex + i;
			const matrixCoord = this.toMatrixCoordinate(memoryIndex);

			this._changeMatrixElement(
				matrixCoord[0],
				matrixCoord[1],
				null,
				this._unloadedColor,
				this._unloadedTextColor
			);
		}
	}

	/// Invoked whenever a memory location is accessed.
	/// @param eventArgs Event arguments generated by the simulation.
	public onMemoryAccessed(eventArgs: OnMemoryAccessedEventArgs): void
	{
		this.clearActiveElement();

		// Set the matrix element to the accessed colors
		const matrixCoord = this.toMatrixCoordinate(eventArgs.index);
		this._changeMatrixElement(
			matrixCoord[0],
			matrixCoord[1],
			eventArgs.newValue,
			this._accessedColor,
			this._accessedTextColor
		);

		// Keep track of which element is active
		this._activeElement = matrixCoord;
	}

	/// Resets the active element to its previous state.
	private clearActiveElement(): void
	{
		// If there is no active element, do nothing
		if (this._activeElement === null)
		{
			return;
		}

		// An element can only become active if it is in the cache, which means
		//   resetting an active element should always set it to the loaded
		//   colors
		const x = this._activeElement[0];
		const y = this._activeElement[1];
		this._changeMatrixElement(
			x,
			y,
			null,
			this._loadedColor,
			this._loadedTextColor
		);

		// Clear the active element
		this._activeElement = null;
	}

	/// Converts the memory location to a matrix element position.
	/// @param memoryLocation Memory location to convert.
	/// @returns The matrix element position.
	private toMatrixCoordinate(
		memoryLocation: number): readonly [number, number]
	{
		const x = memoryLocation % this._matrixX;
		const y = Math.floor(memoryLocation / this._matrixX);
		return [x, y];
	}

	/// Converts the matrix element position to a memory location.
	/// @param matrixX Matrix element X position.
	/// @param matrixY Matrix element Y position.
	/// @returns The memory location.
	private toMemoryIndex(
		matrixX: number,
		matrixY: number): number
	{
		return matrixY * this._matrixX + matrixX;
	}
}
